<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HumanCode - AI × Human Cybersecurity</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #000000;
            color: #ffffff;
            overflow: hidden;
            cursor: default;
        }
        
        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        .top-corner {
            position: absolute;
            top: 2rem;
            left: 2rem;
            font-size: 0.8rem;
            color: #0088ff;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: 600;
            pointer-events: auto;
        }
        
        .top-corner::before {
            content: '//';
            margin-right: 0.5rem;
            opacity: 0.5;
        }
        
        .status-indicator {
            position: absolute;
            top: 2rem;
            right: 2rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.75rem;
            color: #0088ff;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            background: #0088ff;
            border-radius: 50%;
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; box-shadow: 0 0 10px #0088ff; }
            50% { opacity: 0.5; box-shadow: 0 0 20px #0088ff; }
        }
        
        .center-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: auto;
        }
        
        .globe-container {
            position: relative;
            margin-bottom: 3rem;
        }
        
        .subtitle {
            font-size: 0.9rem;
            color: #6b8daf;
            text-transform: uppercase;
            letter-spacing: 3px;
            margin-bottom: 4rem;
            opacity: 0;
            animation: fadeIn 1s ease-out 1s forwards;
        }
        
        @keyframes fadeIn {
            to { opacity: 1; }
        }
        
        .enter-button {
            display: inline-block;
            padding: 1.2rem 3rem;
            background: transparent;
            border: 2px solid #0088ff;
            color: #0088ff;
            text-decoration: none;
            text-transform: uppercase;
            letter-spacing: 3px;
            font-weight: 700;
            font-size: 0.85rem;
            transition: all 0.4s;
            position: relative;
            overflow: hidden;
            cursor: pointer;
            opacity: 0;
            animation: fadeIn 1s ease-out 1.5s forwards;
        }
        
        .enter-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: #0088ff;
            transition: left 0.4s;
            z-index: -1;
        }
        
        .enter-button:hover {
            color: #000000;
            box-shadow: 0 0 30px rgba(0, 136, 255, 0.5);
        }
        
        .enter-button:hover::before {
            left: 0;
        }
        
        .instructions {
            position: absolute;
            bottom: 3rem;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.75rem;
            color: #6b8daf;
            text-transform: uppercase;
            letter-spacing: 2px;
            opacity: 0;
            animation: fadeIn 1s ease-out 2s forwards;
        }
        
        /* Corner brackets */
        .corner-bracket {
            position: absolute;
            width: 60px;
            height: 60px;
            pointer-events: none;
        }
        
        .corner-bracket.tl {
            top: 0;
            left: 0;
            border-top: 2px solid rgba(0, 136, 255, 0.3);
            border-left: 2px solid rgba(0, 136, 255, 0.3);
        }
        
        .corner-bracket.tr {
            top: 0;
            right: 0;
            border-top: 2px solid rgba(0, 136, 255, 0.3);
            border-right: 2px solid rgba(0, 136, 255, 0.3);
        }
        
        .corner-bracket.bl {
            bottom: 0;
            left: 0;
            border-bottom: 2px solid rgba(0, 136, 255, 0.3);
            border-left: 2px solid rgba(0, 136, 255, 0.3);
        }
        
        .corner-bracket.br {
            bottom: 0;
            right: 0;
            border-bottom: 2px solid rgba(0, 136, 255, 0.3);
            border-right: 2px solid rgba(0, 136, 255, 0.3);
        }
        
        .loading-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.9rem;
            color: #0088ff;
            text-transform: uppercase;
            letter-spacing: 2px;
            animation: fadeOut 1s ease-out 0.5s forwards;
        }
        
        @keyframes fadeOut {
            to { opacity: 0; visibility: hidden; }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="ui-overlay">
        <div class="corner-bracket tl"></div>
        <div class="corner-bracket tr"></div>
        <div class="corner-bracket bl"></div>
        <div class="corner-bracket br"></div>
        
        <div class="top-corner">HumanCode v1.0</div>
        <div class="status-indicator">
            <div class="status-dot"></div>
            System Active
        </div>
        
        <div class="loading-text">Initializing...</div>
        
        <div class="center-content">
            <div class="globe-container" id="globe-hint">
                <!-- Globe is rendered on canvas -->
            </div>
            <div class="subtitle">AI × Human Cybersecurity Intelligence</div>
            <a href="#" class="enter-button" id="enter-btn">Enter System</a>
        </div>
        
        <div class="instructions">Drag to rotate • Scroll to zoom</div>
    </div>
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
        
        // 3D Globe made of particles
        class Globe {
            constructor() {
                this.particles = [];
                this.radius = 150;
                this.rotation = { x: 0, y: 0 };
                this.targetRotation = { x: 0, y: 0 };
                this.autoRotate = true;
                this.zoom = 1;
                
                // Create globe particles
                const numParticles = 800;
                for (let i = 0; i < numParticles; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    
                    this.particles.push({
                        theta: theta,
                        phi: phi,
                        x: 0,
                        y: 0,
                        z: 0,
                        size: Math.random() * 1.5 + 0.5,
                        opacity: Math.random() * 0.5 + 0.5
                    });
                }
            }
            
            update() {
                // Smooth rotation
                if (this.autoRotate) {
                    this.targetRotation.y += 0.003;
                }
                this.rotation.x += (this.targetRotation.x - this.rotation.x) * 0.1;
                this.rotation.y += (this.targetRotation.y - this.rotation.y) * 0.1;
                
                // Update particle positions
                this.particles.forEach(p => {
                    const r = this.radius * this.zoom;
                    let x = r * Math.sin(p.phi) * Math.cos(p.theta);
                    let y = r * Math.sin(p.phi) * Math.sin(p.theta);
                    let z = r * Math.cos(p.phi);
                    
                    // Rotate around Y axis
                    const cosY = Math.cos(this.rotation.y);
                    const sinY = Math.sin(this.rotation.y);
                    const x1 = x * cosY - z * sinY;
                    const z1 = x * sinY + z * cosY;
                    
                    // Rotate around X axis
                    const cosX = Math.cos(this.rotation.x);
                    const sinX = Math.sin(this.rotation.x);
                    const y1 = y * cosX - z1 * sinX;
                    const z2 = y * sinX + z1 * cosX;
                    
                    p.x = x1;
                    p.y = y1;
                    p.z = z2;
                });
            }
            
            draw() {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                // Sort particles by z-depth
                const sorted = [...this.particles].sort((a, b) => a.z - b.z);
                
                // Draw connections between nearby particles
                for (let i = 0; i < sorted.length; i++) {
                    const p1 = sorted[i];
                    if (p1.z < -50) continue; // Don't draw back-facing particles
                    
                    for (let j = i + 1; j < Math.min(i + 5, sorted.length); j++) {
                        const p2 = sorted[j];
                        const dx = p1.x - p2.x;
                        const dy = p1.y - p2.y;
                        const dz = p1.z - p2.z;
                        const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                        
                        if (distance < 40) {
                            const opacity = (1 - distance / 40) * 0.3;
                            const depth = (p1.z + p2.z) / 2;
                            const depthFactor = Math.max(0, (depth + 200) / 400);
                            
                            ctx.strokeStyle = `rgba(0, 136, 255, ${opacity * depthFactor})`;
                            ctx.lineWidth = 0.5;
                            ctx.beginPath();
                            ctx.moveTo(centerX + p1.x, centerY + p1.y);
                            ctx.lineTo(centerX + p2.x, centerY + p2.y);
                            ctx.stroke();
                        }
                    }
                }
                
                // Draw particles
                sorted.forEach(p => {
                    if (p.z < -50) return;
                    
                    const depth = (p.z + 200) / 400;
                    const size = p.size * depth;
                    const opacity = p.opacity * depth;
                    
                    ctx.fillStyle = `rgba(0, 136, 255, ${opacity})`;
                    ctx.beginPath();
                    ctx.arc(centerX + p.x, centerY + p.y, size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Glow effect for front particles
                    if (p.z > 50) {
                        ctx.fillStyle = `rgba(0, 136, 255, ${opacity * 0.3})`;
                        ctx.beginPath();
                        ctx.arc(centerX + p.x, centerY + p.y, size * 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
            }
        }
        
        // Orbiting text particles for "HUMANCODE"
        class TextOrbit {
            constructor() {
                this.text = 'HUMANCODE';
                this.particles = [];
                this.radius = 250;
                this.angle = 0;
                
                // Create particles for each letter
                const spacing = (Math.PI * 2) / this.text.length;
                for (let i = 0; i < this.text.length; i++) {
                    this.particles.push({
                        char: this.text[i],
                        angle: i * spacing,
                        radius: this.radius,
                        z: 0
                    });
                }
            }
            
            update() {
                this.angle += 0.005;
                
                this.particles.forEach((p, i) => {
                    const totalAngle = p.angle + this.angle;
                    p.x = Math.cos(totalAngle) * p.radius;
                    p.z = Math.sin(totalAngle) * p.radius;
                    p.y = Math.sin(totalAngle * 2) * 20; // Wavy motion
                });
            }
            
            draw() {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                // Sort by z for proper depth
                const sorted = [...this.particles].sort((a, b) => a.z - b.z);
                
                sorted.forEach(p => {
                    const depth = (p.z + 300) / 600;
                    const opacity = depth * 0.8;
                    const size = 16 * depth;
                    
                    ctx.font = `bold ${size}px 'Courier New', monospace`;
                    ctx.fillStyle = `rgba(0, 136, 255, ${opacity})`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // Glow effect
                    ctx.shadowColor = '#0088ff';
                    ctx.shadowBlur = 10 * depth;
                    ctx.fillText(p.char, centerX + p.x, centerY + p.y);
                    ctx.shadowBlur = 0;
                });
            }
        }
        
        // Background starfield
        class Starfield {
            constructor() {
                this.stars = [];
                for (let i = 0; i < 200; i++) {
                    this.stars.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        size: Math.random() * 1.5,
                        opacity: Math.random() * 0.5 + 0.2,
                        twinkleSpeed: Math.random() * 0.02 + 0.01
                    });
                }
            }
            
            update() {
                this.stars.forEach(star => {
                    star.opacity += star.twinkleSpeed;
                    if (star.opacity > 1 || star.opacity < 0.2) {
                        star.twinkleSpeed *= -1;
                    }
                });
            }
            
            draw() {
                this.stars.forEach(star => {
                    ctx.fillStyle = `rgba(255, 255, 255, ${star.opacity * 0.3})`;
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
        }
        
        const globe = new Globe();
        const textOrbit = new TextOrbit();
        const starfield = new Starfield();
        
        // Mouse interaction
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            globe.autoRotate = false;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;
                
                globe.targetRotation.y += deltaX * 0.005;
                globe.targetRotation.x += deltaY * 0.005;
                
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            }
        });
        
        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            setTimeout(() => {
                globe.autoRotate = true;
            }, 2000);
        });
        
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            globe.zoom += e.deltaY * -0.001;
            globe.zoom = Math.max(0.5, Math.min(2, globe.zoom));
        });
        
        // Animation loop
        function animate() {
            // Clear with fade effect
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            starfield.update();
            starfield.draw();
            
            globe.update();
            globe.draw();
            
            textOrbit.update();
            textOrbit.draw();
            
            requestAnimationFrame(animate);
        }
        
        animate();
        
        // Enter button - would navigate to main site
        document.getElementById('enter-btn').addEventListener('click', (e) => {
    e.preventDefault();
    window.location.href = 'humancode_main_professional.html';
});
    </script>
</body>
</html>
